## Django ORM: ускорение выборки при чтении одной колонки

### Контекст

Есть модель `Movie` с большим количеством полей.

```python
movies = Movie.objects.all()
```

В шаблоне используется только:

```django
{{ movie.name }}
```

Вопрос: загружаются ли все поля и как это ускорить?

---

# 1. Поведение по умолчанию — `all()`

```python
movies = Movie.objects.all()
```

### Что происходит

* Генерируется `SELECT *` (все колонки модели)
* Создаётся объект `Movie` на каждую строку
* Все поля загружаются в память
* Выполняется instantiation модели

### Накладные расходы

* Чтение всех колонок с диска
* Передача всех данных по сети
* Создание Python-объектов
* Дополнительная нагрузка на GC

### Когда это нормально

* Таблица узкая
* Мало строк
* Нет тяжёлых полей (`TextField`, `JSONField`, `BinaryField`)

---

# 2. Частичная загрузка — `only()`

```python
movies = Movie.objects.only("name")
```

### SQL

```sql
SELECT id, name FROM movie;
```

### Что делает

* Загружает только указанные поля (+ `id`)
* Остальные поля помечаются как deferred
* Объекты модели всё равно создаются

### Плюсы

* Меньше I/O
* Меньше сетевого трафика
* Быстрее на "широких" таблицах

### Минусы

Если позже обратиться к другому полю:

```django
{{ movie.description }}
```

→ будет отдельный запрос на каждую строку (N+1)

### Когда использовать

* Таблица широкая
* Нужны именно model instances
* Гарантированно используется ограниченный набор полей

---

# 3. Максимальная оптимизация — `values_list()`

```python
movies = Movie.objects.values_list("name", flat=True)
```

### SQL

```sql
SELECT name FROM movie;
```

### Ключевые отличия

* Выбирается только нужная колонка
* НЕ создаются объекты модели
* Используется `ValuesListIterable`
* Возвращаются строки (или tuple), а не `Movie`

### Плюсы

* Минимальный SQL
* Нет instantiation модели
* Меньше аллокаций
* Ниже потребление памяти
* Быстрее CPU

### Минусы

* Нет методов модели
* Нет связей
* Нет ORM-поведения

### Когда использовать

* Нужны только данные
* Нет необходимости в model logic
* Большие выборки
* API, HTMX, экспорт

---

# 4. Сравнение

| Метод           | Колонки       | Создание модели | Риск N+1 | Производительность       |
| --------------- | ------------- | --------------- | -------- | ------------------------ |
| `all()`         | все           | да              | нет      | базовая                  |
| `only()`        | указанные     | да              | да       | быстрее на wide-таблицах |
| `values_list()` | только нужные | нет             | нет      | максимальная             |

---

# 5. Практические рекомендации

### Маленькая таблица

Оставить `all()` — усложнение не оправдано.

### Широкая таблица + много строк

Использовать `only()`.

### Нужна максимальная эффективность

Использовать `values_list()`.

---

# 6. Как проверить SQL

```python
print(Movie.objects.all().query)
print(Movie.objects.only("name").query)
print(Movie.objects.values_list("name").query)
```

---

# Краткий вывод

* `all()` → удобство
* `only()` → оптимизация I/O
* `values_list()` → оптимизация I/O + CPU + памяти

Если цель — просто вывести список названий,
`values_list("name", flat=True)` — технически наиболее корректный вариант.
